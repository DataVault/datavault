package org.datavaultplatform.broker.services;


import java.nio.charset.StandardCharsets;
import java.security.KeyPair;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.stream.Stream;
import javax.crypto.Cipher;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.datavaultplatform.broker.services.UserKeyPairService.KeyPairInfo;
import org.datavaultplatform.common.crypto.Encryption;
import org.datavaultplatform.common.crypto.SshRsaKeyUtils;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * Tests the Formatted KeyPair generated by UserKeyPairService is valid by...
 * 1) re-reading the formatted KeyPair back into Java PublicKey/PrivateKey pair and
 * 2) checking they have same 'modulus'
 * 3) checking that the key pair can be used to perform Asymmetric RSA Encryption/Decryption
 */
@Slf4j
public class UserKeyPairServiceTest {

  static final String PLAIN_TEXT = "This is a test plain text message.";
  private static final String TEST_PASSPHRASE = "tenet";

  @SneakyThrows
  private static byte[] encrypt(PublicKey publicKey, String plainText) {
    Cipher encryptCipher = newRSACipher();
    encryptCipher.init(Cipher.ENCRYPT_MODE, publicKey);
    byte[] encrypted = encryptCipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
    return encrypted;
  }

  @SneakyThrows
  private static String decrypt(PrivateKey privateKey, byte[] encrypted) {
    Cipher decryptCipher = newRSACipher();
    decryptCipher.init(Cipher.DECRYPT_MODE, privateKey);
    byte[] decrypted = decryptCipher.doFinal(encrypted);
    String plainText = new String(decrypted, StandardCharsets.UTF_8);
    return plainText;
  }

  @SneakyThrows
  private static Cipher newRSACipher() {
    // getInstance is a Factory method (not a 'get singleton instance' method!!!)
    // - it returns fresh non-thread-safe instances on each call
    // - it does NOT return the same RSA singleton instance each time.
    Cipher cipher = Cipher.getInstance("RSA");
    return cipher;
  }


  private static KeyPair getKeyPair(KeyPairInfo info) {
    RSAPublicKey publicKey = SshRsaKeyUtils.readPublicKey(info.getPublicKey());
    RSAPrivateKey privateKey = SshRsaKeyUtils.readPrivateKey(info.getPrivateKey(), TEST_PASSPHRASE);
    KeyPair pair = new KeyPair(publicKey, privateKey);
    return pair;
  }

  // Encrypt with public key - decrypt using private key.
  @ParameterizedTest
  @MethodSource("provideUserKeyPairService")
  @SneakyThrows
  void testKeyPairViaEncryptThenDecrypt(UserKeyPairService service) {

    Encryption.addBouncyCastleSecurityProvider();
    KeyPairInfo info = service.generateNewKeyPair();
    log.info("{}", info.getPublicKey());
    log.info("{}", info.getPrivateKey());
    KeyPair keyPair = getKeyPair(info);

    RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
    RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
    assertEquals(publicKey.getModulus(), privateKey.getModulus());

    byte[] encrypted = encrypt(publicKey, PLAIN_TEXT);
    String plainText2 = decrypt(privateKey, encrypted);

    assertEquals(PLAIN_TEXT, plainText2);
  }

  static Stream<UserKeyPairService> provideUserKeyPairService() {
    return Stream.of (
        new UserKeyPairServiceJSchImpl(TEST_PASSPHRASE),
        new UserKeyPairServiceImpl(TEST_PASSPHRASE)
    );
  }

}
